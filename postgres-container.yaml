---
- name: Deploy PostgreSQL Helm Chart
  hosts: localhost
  vars:
    restIP: "{{ restIP }}"
    restPORT: "{{ restPORT }}"
    helm_chart_name: "{{ helm_chart_name }}"
    helm_chart_version: "{{ helm_chart_version }}"
    helm_release_name: "postgres-{{ ansible_date_time.epoch }}"
    helm_release_namespace: "{{ helm_release_namespace }}"
    db_name: "{{ db_name }}"
    db_mode: "{{ db_mode }}"
    db_type: "{{ db_type }}"
    admin_username: "{{ admin_username }}"
    admin_password: "{{ admin_password }}"
    username: "{{ username }}"
    password: "{{ password }}"
    number_of_replicas: "{{ number_of_replicas }}"
    size: "{{ size }}"
    database: "{{ db_type }}"
    storageClass: "{{ storageClass }}"
    accessMode: "{{ accessMode }}"
  tasks:
    - name: Check if Helm is installed
      command: helm version --short
      register: helm_version
      ignore_errors: yes

    - name: Check if namespace exists
      command: kubectl create namespace {{ helm_release_namespace }}
      register: ns_exists
      ignore_errors: yes
      
    - name: Install Helm if not installed
      command: curl https://raw.githubusercontent.com/helm/helm/master/scripts/get-helm-3 | bash
      when: helm_version.rc != 0

    - name: Add Bitnami Helm repository
      command: helm repo add bitnami https://charts.bitnami.com/bitnami
      ignore_errors: yes

    - name: Create PV & PVC file
      shell: "sed -e 's/RELEASE_NAME/{{ helm_release_name }}/g' -e 's/STORAGE_CLASS/{{ storageClass }}/g' -e 's/SIZE/{{ size }}/g' -e 's/ACCESS_MODE/{{ accessMode }}/g' -e 's/RELEASE_SPACE/{{ helm_release_namespace }}/g' -e 's/DATABASE/{{ database }}/g' -e 's/SUBPTAH/{{ helm_release_name }}/g' database-pv_pvc.yaml > pv-pvc.yaml"
      
    - name: Create PV & PVC
      command: kubectl apply -f pv-pvc.yaml
      register: pv_pvc_install
      
    - name: Deploy PostgreSQL Helm Chart in exclusive Mode
      command: >
        helm install {{ helm_release_name }} {{ helm_chart_name }} -n {{ helm_release_namespace }}
        --set global.postgresql.auth.postgresPassword={{ admin_password }}
        --set global.postgresql.auth.username={{ username }}
        --set global.postgresql.auth.password={{ password }}
        --set global.postgresql.auth.database={{ db_name }}
        --set readReplicas.replicaCount={{ number_of_replicas }}
        --set primary.persistence.existingClaim={{ helm_release_name }}-pvc
        --set volumePermissions.enabled=true
        --set primary.service.type=NodePort
      when: pv_pvc_install.rc == 0 and db_mode == "exclusive"
      register: helm_install_exclusive
    - debug:
        var: helm_install_exclusive.stdout_lines

    - name: Deploy PostgreSQL Helm Chart in shared Mode
      command: >
        helm install {{ helm_release_name }} {{ helm_chart_name }} -n {{ helm_release_namespace }}
        --set global.postgresql.auth.postgresPassword={{ admin_password }}
        --set global.postgresql.auth.database={{ db_name }}
        --set readReplicas.replicaCount={{ number_of_replicas }}
        --set primary.persistence.existingClaim={{ helm_release_name }}-pvc
        --set volumePermissions.enabled=true
        --set primary.service.type=NodePort
      when: pv_pvc_install.rc == 0 and db_mode == "shared"
      register: helm_install_shared
    - debug:
        var: helm_install_shared.stdout_lines
        
    - name: Wait for all pods to be in a 'Running' state
      command: kubectl wait --for=condition=Ready pod -l app.kubernetes.io/instance={{ helm_release_name }} -n {{ helm_release_namespace }} --timeout=300s
      when: helm_install_exclusive.rc == 0 or helm_install_shared.rc == 0

    - name: Print Kubernetes objects created by the Helm chart
      command: kubectl get all -n {{ helm_release_namespace }} -l app.kubernetes.io/instance={{ helm_release_name }}
      register: k8s_objects
      when: helm_install_exclusive.rc == 0 or helm_install_shared.rc == 0
    - debug:
        var: k8s_objects.stdout_lines
      
    - name: Execute kubectl command to get InternalIP
      shell: kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}'
      register: cluster_ip_result
    - debug:
        var: cluster_ip_result.stdout
    
    - name: Execute kubectl command to get PostgreSQL ClusterIP
      shell: kubectl get svc {{ helm_release_name }}-postgresql -o=jsonpath='{.spec.ports[0].nodePort}' -n {{ helm_release_namespace }}
      register: cluster_port_result
    - debug:
        var: cluster_port_result.stdout
        
    - name: Store the results in global variables
      set_fact:
        global_cluster_ip: "{{ cluster_ip_result.stdout }}"
        global_cluster_port: "{{ cluster_port_result.stdout }}"

    - name: Store database info 
      uri:
        url: "http://{{ restIP }}:{{ restPORT }}/platform/v1/database/saveDB"
        method: POST
        body_format: json
        headers:
          Content-Type: "application/json"
        body: >
          {
            "chart_name": "{{ helm_chart_name }}",
            "chart_version": "{{ helm_chart_version }}",
            "release_name": "{{ helm_release_name }}",
            "release_namespace": "{{ helm_release_namespace }}",
            "ip": "{{ global_cluster_ip }}",
            "port": "{{ global_cluster_port }}",
            "db_type": "{{ db_type }}",
            "db_name": "{{ db_name }}",
            "db_mode": "{{ db_mode }}",
            "admin_username": "{{ admin_username }}",
            "admin_password": "{{ admin_password }}",
            "replica_count": "{{ number_of_replicas }}",
            "storage_size": "{{ size }}"
          }
        status_code: 200
      when: cluster_port_result.stdout is defined
      register: post_req_DB
    - debug:
        var: post_req_DB

    - name: Store user's info 
      uri:
        url: "http://{{ restIP }}:{{ restPORT }}/platform/v1/database/saveUser"
        method: POST
        body_format: json
        headers:
          Content-Type: "application/json"
        body: >
          {
            "db_name": "{{ db_name }}",
            "db_type": "{{ db_type }}",
            "db_mode": "{{ db_mode }}",
            "username": "{{ username }}",
            "password": "{{ password }}",
          }
        status_code: 200
      when: post_req_DB is defined
      register: post_req_user
    - debug:
        var: post_req_user

